CAPPEO ENTRE 0 Y 1 :
=IF(A1 < 0, 0, IF(A1 > 1, 1, A1))


ARG_TDEBT_USD, 	 -
ARG_CASHOVER, 	 +
GBL_WPFOOD, 	 -
ARG_GC_N, 	 -
ARG_PSH, 	 +
ARG_M, 	 +
USA_RSH, 	 +
ARG_TDEBT_DOL_G, 	 +
ARG_GDP, 	 -
BRA_GDP, 	 -
USA_RLG, 	 +
GBL_WPO_WTI	 +



The observation that the logarithm of the default rate for the secondary segment (the dependent variable in the regression) is non-stationary is valid, but the issue stems from the nature of the development series. While the series may be sufficient for development purposes, it is too limited to perform this specific test effectively. The relatively short time series did not allow for the capture of expected long-term cycles. It is reasonable to expect that, with a longer history and additional data, cyclical patterns would emerge, making the variable stationary.

To ensure the robustness of the model and avoid spurious relationships, several additional tests were conducted. Among these, we performed a unit root test on the residuals, whose results are presented in the attached table. Across different model specifications (Zero Mean, Single Mean, Trend), the p-values were consistently below 5% for most lags and configurations. This means that the null hypothesis of a unit root was rejected, as indicated by p-values lower than 0.05. This confirms that the residuals are stationary.

The stationarity of the residuals is a crucial indicator of the model’s validity, as it suggests that the model adequately captures the dynamics of the time series, and there is no spurious relationship between the independent and dependent variables.

Additionally, it's important to highlight that the independent predictors were verified to be stationary through individual tests, ensuring that no spurious correlation exists. Therefore, the model is considered reliable and robust.




-...................codigo
import pandas as pd
import numpy as np

# 1. Cargar el archivo CSV
df = pd.read_csv('data.csv')

# 2. Definir las variables clave y sus signos
variables_signos = {
    'ARG_TDEBT_USD': -1,
    'ARG_CASHOVER': 1,
    'GBL_WPFOOD': -1,
    'ARG_GC_N': -1,
    'ARG_PSH': 1,
    'ARG_M': 1,
    'USA_RSH': 1,
    'ARG_TDEBT_DOL_G': 1,
    'ARG_GDP': -1,
    'BRA_GDP': -1,
    'USA_RLG': 1,
    'GBL_WPO_WTI': 1
}

# 3. Convertir la columna 'date' en formato datetime compatible con pandas 1.1.5
df['date'] = pd.to_datetime(df['date'], format='%d/%m/%Y', errors='coerce')

# 4. Filtrar las fechas desde 31/03/2011 hasta 31/03/2024
start_date = pd.Timestamp('2011-03-31')
end_date = pd.Timestamp('2024-03-31')
df_filtered = df[(df['date'] >= start_date) & (df['date'] <= end_date)]

# 5. Inicializar DataFrames para las corridas con el signo positivo y el signo opuesto
df_positive = df_filtered.copy()
df_negative = df_filtered.copy()

# 6. Procesar cada variable del modelo
for variable, signo in variables_signos.items():
    
    # Inicializar lista para almacenar los logaritmos naturales
    ln_ratios = []

    # Para cada fecha desde 31/03/2011 hasta 31/03/2024, calcular el cociente con el mismo trimestre del año anterior
    for i in range(1, len(df_filtered)):
        if i - 4 >= 0:
            # Tomar el valor del trimestre actual (X) y el trimestre del año anterior (X-1)
            current_value = df_filtered[variable].iloc[i]
            previous_value = df_filtered[variable].iloc[i - 4]  # Restar 4 filas para un año

            # Evitar divisiones por cero
            if previous_value != 0:
                # Calcular el cociente entre el valor actual y el valor del año anterior
                ratio = current_value / previous_value
                
                # Calcular el logaritmo natural de este cociente
                ln_ratio = np.log(ratio)
                
                # Agregar el resultado a la lista
                ln_ratios.append(ln_ratio)

    # Calcular el desvío estándar de los logaritmos naturales
    if ln_ratios:
        std_ln = np.std(ln_ratios, ddof=1)
    else:
        std_ln = 0

    # Calcular la exponencial del desvío estándar, tanto positiva como negativa
    exp_positive = np.exp(std_ln)
    exp_negative = np.exp(-std_ln)
    
    # Multiplicar los resultados por el valor de la variable en 31/03/2024
    value_2024 = df[df['date'] == pd.Timestamp('2024-03-31')][variable].values[0]
    
    # Primera corrida: Signo original
    df_positive[variable] = value_2024 * exp_positive
    
    # Segunda corrida: Signo opuesto
    df_negative[variable] = value_2024 * exp_negative
    
    # Si el signo original era negativo, invertimos la corrida
    if signo == -1:
        df_positive[variable] = value_2024 * exp_negative
        df_negative[variable] = value_2024 * exp_positive

# 7. Guardar los resultados en CSV
df_positive.to_csv('corrida_signo_positivo.csv', index=False)
df_negative.to_csv('corrida_signo_negativo.csv', index=False)

print("Corridas generadas y guardadas en archivos CSV.")

--------------------------------------------------------











--------------------------------------------------------------

import pandas as pd
import numpy as np

# 1. Cargar el archivo CSV
df = pd.read_csv('data.csv')

# 2. Definir las variables clave y sus signos
variables_signos = {
    'ARG_TDEBT_USD': -1,
    'ARG_CASHOVER': 1,
    'GBL_WPFOOD': -1,
    'ARG_GC_N': -1,
    'ARG_PSH': 1,
    'ARG_M': 1,
    'USA_RSH': 1,
    'ARG_TDEBT_DOL_G': 1,
    'ARG_GDP': -1,
    'BRA_GDP': -1,
    'USA_RLG': 1,
    'GBL_WPO_WTI': 1
}

# 3. Convertir la columna 'Date' en formato datetime compatible con pandas 1.1.5
df['Date'] = pd.to_datetime(df['Date'], format='%d/%m/%Y', errors='coerce')

# 4. Filtrar las fechas desde 31/03/2010 hasta 31/03/2024 (necesitamos 2010 para los cálculos)
start_date = pd.Timestamp('2010-03-31')
end_date = pd.Timestamp('2024-03-31')
df_filtered = df[(df['Date'] >= start_date) & (df['Date'] <= end_date)]

# 5. Inicializar DataFrames para las corridas con el signo positivo y el signo opuesto
df_positive = df_filtered[df_filtered['Date'] >= '2011-03-31'].copy()
df_negative = df_filtered[df_filtered['Date'] >= '2011-03-31'].copy()

# 6. Procesar cada variable del modelo
for variable, signo in variables_signos.items():
    
    # Inicializar lista para almacenar los logaritmos naturales
    ln_ratios = []

    # Para cada fecha desde 31/03/2011 hasta 31/03/2024, calcular el cociente con el mismo trimestre del año anterior
    for i in range(4, len(df_filtered)):  # Empezamos desde el índice 4 para tener datos del año anterior
        # Tomar el valor del trimestre actual (X) y el trimestre del año anterior (X-1)
        current_value = df_filtered[variable].iloc[i]
        previous_value = df_filtered[variable].iloc[i - 4]  # Restar 4 filas para un año
        
        # Evitar divisiones por cero
        if previous_value != 0:
            # Calcular el cociente entre el valor actual y el valor del año anterior
            ratio = current_value / previous_value
            
            # Calcular el logaritmo natural de este cociente
            ln_ratio = np.log(ratio)
            
            # Agregar el resultado a la lista
            ln_ratios.append(ln_ratio)

    # Calcular el desvío estándar de los logaritmos naturales
    if ln_ratios:
        std_ln = np.std(ln_ratios, ddof=1)
    else:
        std_ln = 0

    # Calcular la exponencial del desvío estándar, tanto positiva como negativa
    exp_positive = np.exp(std_ln)
    exp_negative = np.exp(-std_ln)
    
    # Multiplicar los resultados por el valor de la variable en 31/03/2024
    value_2024 = df[df['Date'] == pd.Timestamp('2024-03-31')][variable].values[0]
    
    # Primera corrida: Signo original
    df_positive[variable] = value_2024 * exp_positive
    
    # Segunda corrida: Signo opuesto
    df_negative[variable] = value_2024 * exp_negative
    
    # Si el signo original era negativo, invertimos la corrida
    if signo == -1:
        df_positive[variable] = value_2024 * exp_negative
        df_negative[variable] = value_2024 * exp_positive

# 7. Guardar los resultados en CSV
df_positive.to_csv('corrida_signo_positivo.csv', index=False)
df_negative.to_csv('corrida_signo_negativo.csv', index=False)

print("Corridas generadas y guardadas en archivos CSV.")


---------------------------------------------------------------



