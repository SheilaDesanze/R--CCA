
import pandas as pd

# Crear un DataFrame con los datos proporcionados
data = {
    'C1': ['Pepe', 'pipo', 'popo'],
    'C2': ['jiji', 'jojo', 'juju'],
    'C3': ['keke', 'Kiki', 'koko']
}
df = pd.DataFrame(data)

# Función para ajustar el texto a 21 caracteres
def ajustar_a_21_caracteres(texto):
    if len(texto) < 21:
        return texto + ' ' * (21 - len(texto))
    return texto

# Aplicar la función a la columna 1, fila 2 (índice 1)
df.at[1, 'C1'] = ajustar_a_21_caracteres(df.at[1, 'C1'])

# Exportar el DataFrame a un archivo txt separado por espacios
df.to_csv('output.txt', sep=' ', index=False, header=False)

# Mostrar el DataFrame resultante
print(df)











import pandas as pd

# Crear un DataFrame de ejemplo
data = {
    'col1': ['texto corto', 'texto largo que necesita ajuste', 'otro texto'],
    'col2': [10, 20, 30],
    'col3': [100, 200, 300]
}
df = pd.DataFrame(data)

# Función para ajustar el texto a 21 caracteres
def ajustar_a_21_caracteres(texto):
    if len(texto) < 21:
        return texto + ' ' * (21 - len(texto))
    return texto

# Aplicar la función a la columna 1, fila 2
df.at[1, 'col1'] = ajustar_a_21_caracteres(df.at[1, 'col1'])

# Mostrar el DataFrame resultante
print(df)





https://foros.3dgames.com.ar/threads/942062-ofertas-online-argentina/page22484

https://www.coursera.org/learn/modelizacion-cuantitativa-para-finanzas-corporativas?action=enroll#modules
DIPLOMATURA EN INTELIGENCIA ARTIFICIAL APLICADA EN GESTIÓN Y ANALÍTICA DE DATOS
CAPPEO ENTRE 0 Y 1 :
=IF(A1 < 0, 0, IF(A1 > 1, 1, A1))

https://store.cfainstitute.org/data-science-for-investment-professionals-certificate/
https://www.argentina.gob.ar/cnv/idoneidad-en-el-mercado-de-capitales/requisitos
https://store.cfainstitute.org/content/DS-Cert-Syllabus-formatted-v2.pdf


que falta imprimir:
- Clases Reaseguro 2C2021 EDITANDO.docx
- Dirube - Manual de Reaseguros.pdf



from tqdm import tqdm
import time

# iniciar la barra de progreso
pbar = tqdm(total=100, desc="Progreso", unit="%")



#tu código, ejemplo para probar: time.sleep(3)
pbar.update(25)  # actualizamos

#sigue tu código, ejemplo para probar: time.sleep(3)
pbar.update(25)  #  actualizamos

#y sigue tu código, ejemplo para probar: time.sleep(3)
pbar.update(50)  # actualizamos 


#finalizar la barra de progreso
pbar.close()


Claro, puedes usar un bucle `for` para comprimir varias carpetas utilizando la función `comprimir_carpeta`. Aquí tienes un ejemplo:

```python
import shutil

def comprimir_carpeta(carpeta_origen, archivo_destino):
    """
    Comprime una carpeta en un archivo ZIP.

    :param carpeta_origen: Ruta de la carpeta que se desea comprimir.
    :param archivo_destino: Ruta del archivo ZIP de destino (sin extensión).
    """
    shutil.make_archive(archivo_destino, 'zip', carpeta_origen)

# Lista de carpetas a comprimir
carpetas_a_comprimir = [
    'ruta/a/tu/carpeta1',
    'ruta/a/tu/carpeta2',
    'ruta/a/tu/carpeta3'
]

# Directorio de destino para los archivos comprimidos
directorio_destino = 'ruta/a/tu/directorio_destino/'

# Comprimir cada carpeta
for carpeta in carpetas_a_comprimir:
    nombre_carpeta = carpeta.split('/')[-1]  # Obtiene el nombre de la carpeta
    archivo_destino = f"{directorio_destino}{nombre_carpeta}_comprimido"
    comprimir_carpeta(carpeta, archivo_destino)
```

### Explicación:
1. **Definición de la función**: La función `comprimir_carpeta` toma una carpeta de origen y un destino, y la comprime en un archivo ZIP.
2. **Lista de carpetas a comprimir**: Se define una lista `carpetas_a_comprimir` que contiene las rutas de las carpetas que deseas comprimir.
3. **Directorio de destino**: Se especifica `directorio_destino` donde se almacenarán los archivos ZIP generados.
4. **Bucle `for`**: Se itera sobre cada carpeta en la lista. Para cada carpeta:
   - Se obtiene el nombre de la carpeta (usando `split('/')[-1]` para obtener la última parte de la ruta).
   - Se construye el nombre del archivo ZIP de destino.
   - Se llama a la función `comprimir_carpeta` para comprimir la carpeta.

Este enfoque permite comprimir múltiples carpetas en un solo paso, almacenando los archivos comprimidos en un directorio especificado. Puedes ajustar las rutas y los nombres de las carpetas según tus necesidades.




import shutil

def comprimir_carpeta(carpeta_origen, archivo_destino):
    shutil.make_archive(archivo_destino, 'zip', carpeta_origen)

# Ejemplo de uso
carpeta_origen = 'ruta/a/tu/carpeta'
archivo_destino = 'ruta/a/tu/archivo_comprimido'


comprimir_carpeta(carpeta_origen, archivo_destino)






# Obtener los nombres de las columnas
columns = [column[0] for column in cursor.description]

# Crear el DataFrame
df = pd.DataFrame([tuple(row) for row in rows], columns=columns)

# Cerrar la conexión
conn.close()

print(df)








import pyodbc
import pandas as pd

# Conectar a la base de datos (ajusta la cadena de conexión según tu configuración)
conn = pyodbc.connect('DRIVER={SQL Server};SERVER=your_server;DATABASE=your_db;UID=your_user;PWD=your_password')

# Ejecutar una consulta
cursor = conn.cursor()
cursor.execute('SELECT * FROM your_table')

# Obtener todos los resultados en una lista de pyodbc.Row objects
rows = cursor.fetchall()

# Obtener los nombres de las columnas
columns = [column[0] for column in cursor.description]

# Crear el DataFrame
df = pd.DataFrame([tuple(row) for row in rows], columns=columns)

# Cerrar la conexión
conn.close()

print(df)











.... nuevo .....
import re

def identificar_simbolos(ruta_archivo):
  with open(ruta_archivo, "r", encoding="utf-8") as archivo:
    contenido = archivo.read()

  # Buscar patrones comunes
  if re.search(r"^[a-zA-Z0-9\s.,;:\-()\[\]{}]+$", contenido):
    return "Texto plano"
  elif re.search(r"<html>", contenido):
    return "HTML"
  elif re.search(r"import|def|class", contenido):
    return "Python"
  # Agregar más patrones según sea necesario

  return "Desconocido"

ruta_archivo = "tu_archivo.txt"  # Reemplaza con la ruta real
resultado = identificar_simbolos(ruta_archivo)
print(f"El archivo parece contener: {resultado}")






mmmmmmm.....



datos = [10, 25, "hola", 3.14]

with open("datos.txt", "w") as archivo:
    for elemento in datos:
        archivo.write(str(elemento) + " ")  # Agrega un espacio después de cada elemento
