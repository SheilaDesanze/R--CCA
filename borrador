CAPPEO ENTRE 0 Y 1 :
=IF(A1 < 0, 0, IF(A1 > 1, 1, A1))


ARG_TDEBT_USD, 	 -
ARG_CASHOVER, 	 +
GBL_WPFOOD, 	 -
ARG_GC_N, 	 -
ARG_PSH, 	 +
ARG_M, 	 +
USA_RSH, 	 +
ARG_TDEBT_DOL_G, 	 +
ARG_GDP, 	 -
BRA_GDP, 	 -
USA_RLG, 	 +
GBL_WPO_WTI	 +



The observation that the logarithm of the default rate for the secondary segment (the dependent variable in the regression) is non-stationary is valid, but the issue stems from the nature of the development series. While the series may be sufficient for development purposes, it is too limited to perform this specific test effectively. The relatively short time series did not allow for the capture of expected long-term cycles. It is reasonable to expect that, with a longer history and additional data, cyclical patterns would emerge, making the variable stationary.

To ensure the robustness of the model and avoid spurious relationships, several additional tests were conducted. Among these, we performed a unit root test on the residuals, whose results are presented in the attached table. Across different model specifications (Zero Mean, Single Mean, Trend), the p-values were consistently below 5% for most lags and configurations. This means that the null hypothesis of a unit root was rejected, as indicated by p-values lower than 0.05. This confirms that the residuals are stationary.

The stationarity of the residuals is a crucial indicator of the model’s validity, as it suggests that the model adequately captures the dynamics of the time series, and there is no spurious relationship between the independent and dependent variables.

Additionally, it's important to highlight that the independent predictors were verified to be stationary through individual tests, ensuring that no spurious correlation exists. Therefore, the model is considered reliable and robust.




-...................codigo
import pandas as pd
import numpy as np

# 1. Cargar el archivo CSV
df = pd.read_csv('data.csv')

# 2. Definir las variables clave y sus signos
variables_signos = {
    'ARG_TDEBT_USD': -1,
    'ARG_CASHOVER': 1,
    'GBL_WPFOOD': -1,
    'ARG_GC_N': -1,
    'ARG_PSH': 1,
    'ARG_M': 1,
    'USA_RSH': 1,
    'ARG_TDEBT_DOL_G': 1,
    'ARG_GDP': -1,
    'BRA_GDP': -1,
    'USA_RLG': 1,
    'GBL_WPO_WTI': 1
}

# 3. Convertir la columna 'Date' a datetime compatible con pandas 1.1.5
df['Date'] = pd.to_datetime(df['Date'], format='%d/%m/%Y', errors='coerce')

# 4. Filtrar las fechas desde 31/03/2010 hasta 31/03/2024
start_date = pd.Timestamp('2010-03-31')
end_date = pd.Timestamp('2024-03-31')
df_filtered = df[(df['Date'] >= start_date) & (df['Date'] <= end_date)].copy()

# 5. Crear DataFrames para los dos escenarios de resultados
df_model_sign = df_filtered.copy()  # Respeta el signo del modelo
df_opposite_sign = df_filtered.copy()  # Usa el signo opuesto al modelo

# 6. Procesar cada variable
for variable, signo in variables_signos.items():
    
    # Inicializar lista para almacenar los logaritmos naturales de los cocientes desde 2011
    ln_ratios = []

    # 7. Calcular los cocientes desde 31/03/2011 hasta 31/03/2024
    for i in range(4, len(df_filtered)):  # Comenzamos en el índice 4 (31/03/2011)
        current_value = df_filtered[variable].iloc[i]
        previous_value = df_filtered[variable].iloc[i - 4]  # Mismo trimestre del año anterior
        
        # Evitar divisiones por cero
        if previous_value != 0:
            # Calcular el cociente entre los trimestres correspondientes
            ratio = current_value / previous_value
            
            # Calcular el logaritmo natural de este cociente
            ln_ratio = np.log(ratio)
            
            # Guardar el logaritmo natural solo desde 2011 (índice 4) en adelante
            ln_ratios.append(ln_ratio)

    # 8. Calcular el desvío estándar de los logaritmos naturales SOLO desde 2011 a 2024
    if ln_ratios:
        std_ln = np.std(ln_ratios, ddof=1)  # ddof=1 para el desvío estándar de la muestra
    else:
        std_ln = 0

    # 9. Calcular los valores exponenciales para el desvío positivo y negativo
    exp_positive = np.exp(std_ln)
    exp_negative = np.exp(-std_ln)

    # 10. Multiplicar los resultados por el valor en 31/03/2024
    value_2024 = df_filtered[df_filtered['Date'] == pd.Timestamp('2024-03-31')][variable].values[0]
    
    # 11. Escenario 1: Respetar el signo original del modelo
    if signo == 1:  # Si el signo es positivo en el modelo
        df_model_sign.loc[df_model_sign['Date'] == pd.Timestamp('2024-03-31'), variable] = value_2024 * exp_positive
    else:  # Si el signo es negativo en el modelo
        df_model_sign.loc[df_model_sign['Date'] == pd.Timestamp('2024-03-31'), variable] = value_2024 * exp_negative
    
    # 12. Escenario 2: Usar el signo opuesto
    if signo == 1:  # Si el signo es positivo en el modelo
        df_opposite_sign.loc[df_opposite_sign['Date'] == pd.Timestamp('2024-03-31'), variable] = value_2024 * exp_negative
    else:  # Si el signo es negativo en el modelo
        df_opposite_sign.loc[df_opposite_sign['Date'] == pd.Timestamp('2024-03-31'), variable] = value_2024 * exp_positive

# 13. Filtrar los DataFrames para incluir solo las fechas desde 31/03/2011
df_model_sign = df_model_sign[df_model_sign['Date'] >= pd.Timestamp('2011-03-31')]
df_opposite_sign = df_opposite_sign[df_opposite_sign['Date'] >= pd.Timestamp('2011-03-31')]

# 14. Guardar los resultados en archivos CSV
df_model_sign.to_csv('corrida_signo_modelo.csv', index=False)
df_opposite_sign.to_csv('corrida_signo_opuesto.csv', index=False)

print("Corridas generadas y guardadas en archivos CSV.")



---------------------------------------------------------------


-----__________________
_________________________________________________________________
import pandas as pd
import numpy as np

# 1. Cargar el archivo CSV
df = pd.read_csv('data.csv')

# 2. Definir las variables clave y sus signos
variables_signos = {
    'ARG_TDEBT_USD': -1,
    'ARG_CASHOVER': 1,
    'GBL_WPFOOD': -1,
    'ARG_GC_N': -1,
    'ARG_PSH': 1,
    'ARG_M': 1,
    'USA_RSH': 1,
    'ARG_TDEBT_DOL_G': 1,
    'ARG_GDP': -1,
    'BRA_GDP': -1,
    'USA_RLG': 1,
    'GBL_WPO_WTI': 1
}

# 3. Convertir la columna 'Date' a datetime con compatibilidad para pandas 1.1.5
df['Date'] = pd.to_datetime(df['Date'], format='%d/%m/%Y', errors='coerce')

# 4. Filtrar las fechas desde 31/03/2010 hasta 31/03/2024
start_date = pd.Timestamp('2010-03-31')
end_date = pd.Timestamp('2024-03-31')
df_filtered = df[(df['Date'] >= start_date) & (df['Date'] <= end_date)].copy()

# 5. Crear DataFrames de resultados positivos y negativos a partir del DataFrame filtrado
df_positive = df_filtered.copy()
df_negative = df_filtered.copy()

# 6. Procesar cada variable
for variable, signo in variables_signos.items():
    
    # Inicializar lista para almacenar los logaritmos naturales de los cocientes desde 2011
    ln_ratios = []

    # 7. Calcular los cocientes desde 31/03/2011 hasta 31/03/2024
    for i in range(4, len(df_filtered)):  # Comenzamos en el índice 4 (31/03/2011)
        current_value = df_filtered[variable].iloc[i]
        previous_value = df_filtered[variable].iloc[i - 4]  # Mismo trimestre del año anterior
        
        # Evitar divisiones por cero
        if previous_value != 0:
            # Calcular el cociente entre los trimestres correspondientes
            ratio = current_value / previous_value
            
            # Calcular el logaritmo natural de este cociente
            ln_ratio = np.log(ratio)
            
            # Guardar el logaritmo natural solo desde 2011 (índice 4) en adelante
            ln_ratios.append(ln_ratio)

    # 8. Calcular el desvío estándar de los logaritmos naturales SOLO desde 2011 a 2024
    if ln_ratios:
        std_ln = np.std(ln_ratios, ddof=1)  # ddof=1 para el desvío estándar de la muestra
    else:
        std_ln = 0

    # 9. Calcular los valores exponenciales para el desvío positivo y negativo
    exp_positive = np.exp(std_ln)
    exp_negative = np.exp(-std_ln)

    # 10. Multiplicar los resultados por el valor en 31/03/2024
    value_2024 = df_filtered[df_filtered['Date'] == pd.Timestamp('2024-03-31')][variable].values[0]
    
    # Actualizar el valor en 31/03/2024 en los DataFrames df_positive y df_negative
    df_positive.loc[df_positive['Date'] == pd.Timestamp('2024-03-31'), variable] = value_2024 * exp_positive
    df_negative.loc[df_negative['Date'] == pd.Timestamp('2024-03-31'), variable] = value_2024 * exp_negative

# 11. Filtrar los DataFrames positivos y negativos para incluir solo las fechas desde 31/03/2011
df_positive = df_positive[df_positive['Date'] >= pd.Timestamp('2011-03-31')]
df_negative = df_negative[df_negative['Date'] >= pd.Timestamp('2011-03-31')]

# 12. Guardar los resultados en archivos CSV
df_positive.to_csv('corrida_signo_positivo.csv', index=False)
df_negative.to_csv('corrida_signo_negativo.csv', index=False)

print("Corridas generadas y guardadas en archivos CSV.")




-----------------

